<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Simulating Rust Trait in C++ | Bluempty</title>
<meta name=keywords content="Coding"><meta name=description content="I got in touch with rust quite early and watched its ecosystem gradually improve.
When I first used trait, I wondered how to implement such a great feature in c++.
Though it wasn&rsquo;t an urgent need, I put it aside. Recently, I tried to implement it in a simple way.
Rust Trait
Let&rsquo;s first look at an example of rust trait.
Simply put, it&rsquo;s about defining interfaces, implementing interfaces, and interface polymorphism.
Actually, c++ already has a complete inheritance paradigm to implement these requirements - virtual interface, inheritance implementation, virtual polymorphism.
However, virtual functions require forced dynamic dispatch and add virtual table pointers to class instances.
So let&rsquo;s try to implement trait without using virtual inheritance."><meta name=author content="hypengw"><link rel=canonical href=https://blog.bluempty.com/en/post/cpp-rust-trait/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.bluempty.com/images/profile.webp><link rel=icon type=image/png sizes=16x16 href=https://blog.bluempty.com/images/profile.webp><link rel=icon type=image/png sizes=32x32 href=https://blog.bluempty.com/images/profile.webp><link rel=apple-touch-icon href=https://blog.bluempty.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.bluempty.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.bluempty.com/post/cpp-rust-trait/><link rel=alternate hreflang=en href=https://blog.bluempty.com/en/post/cpp-rust-trait/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/css/dimbox.min.css><meta property="og:url" content="https://blog.bluempty.com/en/post/cpp-rust-trait/"><meta property="og:site_name" content="Bluempty"><meta property="og:title" content="Simulating Rust Trait in C++"><meta property="og:description" content="I got in touch with rust quite early and watched its ecosystem gradually improve.
When I first used trait, I wondered how to implement such a great feature in c++.
Though it wasn’t an urgent need, I put it aside. Recently, I tried to implement it in a simple way.
Rust Trait Let’s first look at an example of rust trait.
Simply put, it’s about defining interfaces, implementing interfaces, and interface polymorphism.
Actually, c++ already has a complete inheritance paradigm to implement these requirements - virtual interface, inheritance implementation, virtual polymorphism.
However, virtual functions require forced dynamic dispatch and add virtual table pointers to class instances.
So let’s try to implement trait without using virtual inheritance."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-03-12T22:11:24+08:00"><meta property="article:modified_time" content="2025-03-12T22:11:24+08:00"><meta property="article:tag" content="Coding"><meta name=twitter:card content="summary"><meta name=twitter:title content="Simulating Rust Trait in C++"><meta name=twitter:description content="I got in touch with rust quite early and watched its ecosystem gradually improve.
When I first used trait, I wondered how to implement such a great feature in c++.
Though it wasn&rsquo;t an urgent need, I put it aside. Recently, I tried to implement it in a simple way.
Rust Trait
Let&rsquo;s first look at an example of rust trait.
Simply put, it&rsquo;s about defining interfaces, implementing interfaces, and interface polymorphism.
Actually, c++ already has a complete inheritance paradigm to implement these requirements - virtual interface, inheritance implementation, virtual polymorphism.
However, virtual functions require forced dynamic dispatch and add virtual table pointers to class instances.
So let&rsquo;s try to implement trait without using virtual inheritance."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.bluempty.com/en/post/"},{"@type":"ListItem","position":2,"name":"Simulating Rust Trait in C++","item":"https://blog.bluempty.com/en/post/cpp-rust-trait/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Simulating Rust Trait in C++","name":"Simulating Rust Trait in C\u002b\u002b","description":"I got in touch with rust quite early and watched its ecosystem gradually improve.\nWhen I first used trait, I wondered how to implement such a great feature in c++.\nThough it wasn\u0026rsquo;t an urgent need, I put it aside. Recently, I tried to implement it in a simple way.\nRust Trait Let\u0026rsquo;s first look at an example of rust trait.\nSimply put, it\u0026rsquo;s about defining interfaces, implementing interfaces, and interface polymorphism.\nActually, c++ already has a complete inheritance paradigm to implement these requirements - virtual interface, inheritance implementation, virtual polymorphism.\nHowever, virtual functions require forced dynamic dispatch and add virtual table pointers to class instances.\nSo let\u0026rsquo;s try to implement trait without using virtual inheritance.\n","keywords":["Coding"],"articleBody":"I got in touch with rust quite early and watched its ecosystem gradually improve.\nWhen I first used trait, I wondered how to implement such a great feature in c++.\nThough it wasn’t an urgent need, I put it aside. Recently, I tried to implement it in a simple way.\nRust Trait Let’s first look at an example of rust trait.\nSimply put, it’s about defining interfaces, implementing interfaces, and interface polymorphism.\nActually, c++ already has a complete inheritance paradigm to implement these requirements - virtual interface, inheritance implementation, virtual polymorphism.\nHowever, virtual functions require forced dynamic dispatch and add virtual table pointers to class instances.\nSo let’s try to implement trait without using virtual inheritance.\nkeywords trait → Defines a trait. trait Speak { fn speak(\u0026self) -\u003e String; } impl → Implements a trait for a type. struct Dog; impl Speak for Dog { fn speak(\u0026self) -\u003e String { \"Woof!\".to_string() } } where → Adds trait bounds in a structured way. fn make_speak\u003cT\u003e(animal: T) where T: Speak { println!(\"{}\", animal.speak()); } dyn → Used for dynamic dispatch. fn speak_dyn(animal: \u0026dyn Speak) { println!(\"{}\", animal.speak()); } C++ Implementation Complete code The specific implementation may change, refer to the documentation in the repo\nInterface Definition When there’s no reflection for code generation, the interface needs to include delegate functionality\nrequires can only be used as constraints; it cannot be materialized into concrete functions, so we need to define concrete interface classes.\nNow we can define any interface class and write a set of function declarations.\nThen how do we call the implementation through the interface? For concrete instances, they should have concrete implementation functions that can be called normally. But considering the implementation of dyn, and that C++ cannot generate variable/function names through templates, I thought about having the interface class carry its own delegate implementation, which calls different implementations based on different situations.\ntemplate\u003ctypename T\u003e struct Speak { auto speak() -\u003e std::string { return M::template call\u003c0\u003e(this); } private: using M = TraitMeta\u003cSpeak, T\u003e; friend M; template\u003ctypename F\u003e static consteval auto collect() { return TraitApi { \u0026F::speak }; } }; template call: Looks up the function in the vtable and then calls it. For vtable, static dispatch references constexpr static variables, while dynamic dispatch references through pointers. collect: Helps to get the type and address of the interface without reflection. Since it’s a template, it can also be used to verify if the interface is correctly implemented. TraitApi: Internally, it’s a simple tuple that stores type information and addresses. Interface Implementation Common Customization Points in c++ include overloading, template specialization, Policy, and ADL.\nHere we choose template specialization, which is similar to how rust implements it.\nFor example, the Orphan Rule, which is the orphan principle for trait:\nImplement external Trait for your own types Implement your own Trait for external types From the perspective of c++, it’s easy to understand that these two rules ensure that the implementation of the Trait (i.e., template specialization) is visible to the compilation unit that references it (i.e., the .cpp/.cc that references the .h).\nThis avoids generating different implementations in different compilation units.\nstruct Dog; template\u003c\u003e struct Impl\u003cSpeak, Dog\u003e { static auto speak(TraitPtr self) -\u003e std::string; }; struct Dog : Speak\u003cDog\u003e { std::string voice {\"Woof!\"}; }; auto Impl\u003cSpeak, Dog\u003e::speak(TraitPtr self) -\u003e std::string { return self.as_ref\u003cDog\u003e().voice; } ... Impl accepts a Trait template and a concrete type. : Speak non-virtual inheritance allows the Dog class to have concrete interface functions, i.e., Dog().speak(). Impl::speak(Dog()) directly calls the implementation. It’s better to separate the fields definition of Dog.\nThis way, you can directly operate on Dog fields even when Dog is not yet defined.\nstruct Dog; struct DogFields { std::string voice {\"Woof!\"}; }; // Impl Speak ... struct Dog : DogFields, Speak\u003cDog\u003e {} Static Dispatch Use std::semiregular to determine if Impl is fully defined, or you can write a template to check the size.\ntemplate\u003ctypename A, template\u003ctypename\u003e class... T\u003e concept Implemented = (std::semiregular\u003cImpl\u003cT, A\u003e\u003e \u0026\u0026 ...); // ... template\u003ctypename T\u003e requires Implemented\u003cT, Speak\u003e void make_speak(T\u0026 animal) { std::print(\"{}\", animal.speak()); } dyn Fat Pointer It stores a vtable pointer and a self pointer.\nThen use the dispatch functionality of the interface class to make the call.\ntemplate\u003ctemplate\u003ctypename\u003e class Tr, ConstNess Cn\u003e class Dyn : public Tr\u003cDynImpl\u003cTr\u003e\u003e { using M = TraitMeta\u003cTr, DynImpl\u003cTr\u003e\u003e; friend M; using ptr_t = std::conditional_t\u003cCn == ConstNess::Const, const TraitPtr, TraitPtr\u003e; const decltype(M::apis)* const apis; ptr_t self; ... } // ... Dog dog; auto dyn = make_dyn\u003cSpeak\u003e(dog); std::print(\"{}\", dyn.speak()); Tr: A Trait interface Tr","wordCount":"782","inLanguage":"en","datePublished":"2025-03-12T22:11:24+08:00","dateModified":"2025-03-12T22:11:24+08:00","author":{"@type":"Person","name":"hypengw"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.bluempty.com/en/post/cpp-rust-trait/"},"publisher":{"@type":"Organization","name":"Bluempty","logo":{"@type":"ImageObject","url":"https://blog.bluempty.com/images/profile.webp"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.bluempty.com/en/ accesskey=h title="Bluempty (Alt + H)">Bluempty</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.bluempty.com/ title=Zh aria-label=Zh>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://blog.bluempty.com/en/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.bluempty.com/en/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.bluempty.com/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.bluempty.com/en/friends/ title=Friends><span>Friends</span></a></li><li><a href=https://blog.bluempty.com/en/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.bluempty.com/en/>Home</a>&nbsp;»&nbsp;<a href=https://blog.bluempty.com/en/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Simulating Rust Trait in C++</h1><div class=post-meta><span title='2025-03-12 22:11:24 +0800 +0800'>March 12, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;hypengw&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://blog.bluempty.com/post/cpp-rust-trait/>Zh</a></li></ul></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#rust-trait aria-label="Rust Trait">Rust Trait</a><ul><li><a href=#keywords aria-label=keywords>keywords</a></li></ul></li><li><a href=#c-implementation aria-label="C++ Implementation">C++ Implementation</a><ul><li><a href=#interface-definition aria-label="Interface Definition">Interface Definition</a></li><li><a href=#interface-implementation aria-label="Interface Implementation">Interface Implementation</a></li><li><a href=#static-dispatch aria-label="Static Dispatch">Static Dispatch</a></li><li><a href=#dyn-fat-pointer aria-label="dyn Fat Pointer">dyn Fat Pointer</a></li><li><a href=#box-dyn aria-label="Box dyn">Box dyn</a></li></ul></li></ul></div></details></div><div class=post-content><p>I got in touch with <code>rust</code> quite early and watched its ecosystem gradually improve.<br>When I first used <code>trait</code>, I wondered how to implement such a great feature in <code>c++</code>.<br>Though it wasn&rsquo;t an urgent need, I put it aside. Recently, I tried to implement it in a simple way.</p><h2 id=rust-trait>Rust Trait<a hidden class=anchor aria-hidden=true href=#rust-trait>#</a></h2><p>Let&rsquo;s first look at an example of rust trait.<br>Simply put, it&rsquo;s about <em>defining interfaces, implementing interfaces, and interface polymorphism</em>.<br>Actually, <code>c++</code> already has a complete inheritance paradigm to implement these requirements - <em>virtual interface, inheritance implementation, virtual polymorphism</em>.<br>However, virtual functions require forced dynamic dispatch and add virtual table pointers to class instances.<br>So let&rsquo;s try to implement <code>trait</code> without using virtual inheritance.</p><h3 id=keywords>keywords<a hidden class=anchor aria-hidden=true href=#keywords>#</a></h3><ul><li>trait → Defines a trait.<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>Speak</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>speak</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>String</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li>impl → Implements a trait for a type.<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Dog</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Speak</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Dog</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>speak</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>String</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=s>&#34;Woof!&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li>where → Adds trait bounds in a structured way.<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>make_speak</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>animal</span>: <span class=nc>T</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>T</span>: <span class=nc>Speak</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>animal</span><span class=p>.</span><span class=n>speak</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li>dyn → Used for dynamic dispatch.<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>speak_dyn</span><span class=p>(</span><span class=n>animal</span>: <span class=kp>&amp;</span><span class=nc>dyn</span><span class=w> </span><span class=n>Speak</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>animal</span><span class=p>.</span><span class=n>speak</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li></ul><h2 id=c-implementation>C++ Implementation<a hidden class=anchor aria-hidden=true href=#c-implementation>#</a></h2><p><a href=https://github.com/hypengw/rstd/blob/master/src/core/trait.cppm>Complete code</a><br>The specific implementation may change, refer to the documentation in the repo</p><h3 id=interface-definition>Interface Definition<a hidden class=anchor aria-hidden=true href=#interface-definition>#</a></h3><blockquote><p>When there&rsquo;s no reflection for code generation, the interface needs to include delegate functionality</p></blockquote><p><code>requires</code> can only be used as constraints; it cannot be materialized into concrete functions, so we need to define concrete interface classes.<br>Now we can define any interface class and write a set of function declarations.<br>Then how do we call the implementation through the interface? For concrete instances, they should have concrete implementation functions that can be called normally. But considering the implementation of <code>dyn</code>, and that <strong>C++ cannot generate variable/function names through templates</strong>, I thought about having the interface class carry its own <code>delegate</code> implementation, which calls different implementations based on different situations.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Speak</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=nf>speak</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=p>{</span> <span class=k>return</span> <span class=n>M</span><span class=o>::</span><span class=k>template</span> <span class=n>call</span><span class=o>&lt;</span><span class=mi>0</span><span class=o>&gt;</span><span class=p>(</span><span class=k>this</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>M</span> <span class=o>=</span> <span class=n>TraitMeta</span><span class=o>&lt;</span><span class=n>Speak</span><span class=p>,</span> <span class=n>T</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=n>M</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>F</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>consteval</span> <span class=k>auto</span> <span class=n>collect</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>TraitApi</span> <span class=p>{</span> <span class=o>&amp;</span><span class=n>F</span><span class=o>::</span><span class=n>speak</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ul><li><code>template call&lt;X></code>: Looks up the function in the <code>vtable</code> and then calls it.
For <code>vtable</code>, static dispatch references <code>constexpr static</code> variables, while dynamic dispatch references through pointers.</li><li><code>collect</code>: Helps to get the type and address of the interface without reflection. Since it&rsquo;s a template, it can also be used to verify if the interface is correctly implemented.</li><li><code>TraitApi</code>: Internally, it&rsquo;s a simple <code>tuple</code> that stores type information and addresses.</li></ul><h3 id=interface-implementation>Interface Implementation<a hidden class=anchor aria-hidden=true href=#interface-implementation>#</a></h3><p>Common <code>Customization Points</code> in <code>c++</code> include overloading, template specialization, Policy, and ADL.<br>Here we choose template specialization, which is similar to how <code>rust</code> implements it.<br>For example, the <code>Orphan Rule</code>, which is the orphan principle for <code>trait</code>:</p><ul><li>Implement external Trait for your own types</li><li>Implement your own Trait for external types</li></ul><p>From the perspective of <code>c++</code>, it&rsquo;s easy to understand that these two rules ensure that the implementation of the Trait (i.e., template specialization) is visible to the compilation unit that references it (i.e., the <code>.cpp/.cc</code> that references the <code>.h</code>).<br>This avoids generating different implementations in different compilation units.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Dog</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Impl</span><span class=o>&lt;</span><span class=n>Speak</span><span class=p>,</span> <span class=n>Dog</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>auto</span> <span class=nf>speak</span><span class=p>(</span><span class=n>TraitPtr</span> <span class=n>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Dog</span> <span class=o>:</span> <span class=n>Speak</span><span class=o>&lt;</span><span class=n>Dog</span><span class=o>&gt;</span>  <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>voice</span> <span class=p>{</span><span class=s>&#34;Woof!&#34;</span><span class=p>};</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>Impl</span><span class=o>&lt;</span><span class=n>Speak</span><span class=p>,</span> <span class=n>Dog</span><span class=o>&gt;::</span><span class=n>speak</span><span class=p>(</span><span class=n>TraitPtr</span> <span class=n>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>self</span><span class=p>.</span><span class=n>as_ref</span><span class=o>&lt;</span><span class=n>Dog</span><span class=o>&gt;</span><span class=p>().</span><span class=n>voice</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span></code></pre></div><ul><li><code>Impl</code> accepts a Trait template and a concrete type.</li><li><code>: Speak&lt;Dog></code> non-virtual inheritance allows the <code>Dog</code> class to have concrete interface functions, i.e., <code>Dog().speak()</code>.</li><li><code>Impl&lt;Speak, Dog>::speak(Dog())</code> directly calls the implementation.</li></ul><p>It&rsquo;s better to separate the <code>fields</code> definition of <code>Dog</code>.<br>This way, you can directly operate on <code>Dog fields</code> even when <code>Dog</code> is not yet defined.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Dog</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>DogFields</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>voice</span> <span class=p>{</span><span class=s>&#34;Woof!&#34;</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// Impl Speak&lt;Dog&gt; ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>Dog</span> <span class=o>:</span> <span class=n>DogFields</span><span class=p>,</span> <span class=n>Speak</span><span class=o>&lt;</span><span class=n>Dog</span><span class=o>&gt;</span> <span class=p>{}</span>
</span></span></code></pre></div><h3 id=static-dispatch>Static Dispatch<a hidden class=anchor aria-hidden=true href=#static-dispatch>#</a></h3><p>Use <code>std::semiregular</code> to determine if <code>Impl</code> is fully defined, or you can write a template to check the <code>size</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>A</span><span class=p>,</span> <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span><span class=o>&gt;</span> <span class=k>class</span><span class=err>... </span><span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>concept</span> <span class=n>Implemented</span> <span class=o>=</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>semiregular</span><span class=o>&lt;</span><span class=n>Impl</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>A</span><span class=o>&gt;&gt;</span> <span class=o>&amp;&amp;</span> <span class=p>...);</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>requires</span> <span class=n>Implemented</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>Speak</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>make_speak</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span> <span class=n>animal</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>print</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span> <span class=n>animal</span><span class=p>.</span><span class=n>speak</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=dyn-fat-pointer>dyn Fat Pointer<a hidden class=anchor aria-hidden=true href=#dyn-fat-pointer>#</a></h3><p>It stores a <code>vtable</code> pointer and a <code>self</code> pointer.<br>Then use the dispatch functionality of the interface class to make the call.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Tr</span><span class=p>,</span> <span class=n>ConstNess</span> <span class=n>Cn</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Dyn</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Tr</span><span class=o>&lt;</span><span class=n>DynImpl</span><span class=o>&lt;</span><span class=n>Tr</span><span class=o>&gt;&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>M</span> <span class=o>=</span> <span class=n>TraitMeta</span><span class=o>&lt;</span><span class=n>Tr</span><span class=p>,</span> <span class=n>DynImpl</span><span class=o>&lt;</span><span class=n>Tr</span><span class=o>&gt;&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=n>M</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>ptr_t</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>conditional_t</span><span class=o>&lt;</span><span class=n>Cn</span> <span class=o>==</span> <span class=n>ConstNess</span><span class=o>::</span><span class=n>Const</span><span class=p>,</span> <span class=k>const</span> <span class=n>TraitPtr</span><span class=p>,</span> <span class=n>TraitPtr</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=nf>decltype</span><span class=p>(</span><span class=n>M</span><span class=o>::</span><span class=n>apis</span><span class=p>)</span><span class=o>*</span> <span class=k>const</span> <span class=n>apis</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ptr_t</span>                          <span class=n>self</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>Dog</span> <span class=n>dog</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>dyn</span> <span class=o>=</span> <span class=n>make_dyn</span><span class=o>&lt;</span><span class=n>Speak</span><span class=o>&gt;</span><span class=p>(</span><span class=n>dog</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>print</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span> <span class=n>dyn</span><span class=p>.</span><span class=n>speak</span><span class=p>());</span>
</span></span></code></pre></div><ul><li><code>Tr</code>: A <code>Trait</code> interface</li><li><code>Tr&lt;DynImpl&lt;Tr>></code>: Uses the <code>DynImpl</code> tag to mark <code>Tr</code>, generating concrete call functions</li><li><code>apis</code>: <code>vtable</code> pointer</li><li><code>Cn</code>: <code>Tr</code> cannot have a <code>const</code> tag, so an additional parameter is needed to mark <code>ConstNess</code></li></ul><h3 id=box-dyn>Box dyn<a hidden class=anchor aria-hidden=true href=#box-dyn>#</a></h3><p>TODO</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.bluempty.com/en/tags/coding/>Coding</a></li></ul></footer></article></main><footer class=footer><span>© 2025 <a href=https://blog.bluempty.com>Bluempty</a> · <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=/js/dimbox.min.js></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>