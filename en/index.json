[{"content":"I got in touch with rust quite early and watched its ecosystem gradually improve.\nWhen I first used trait, I wondered how to implement such a great feature in c++.\nThough it wasn\u0026rsquo;t an urgent need, I put it aside. Recently, I tried to implement it in a simple way.\nRust Trait Let\u0026rsquo;s first look at an example of rust trait.\nSimply put, it\u0026rsquo;s about defining interfaces, implementing interfaces, and interface polymorphism.\nActually, c++ already has a complete inheritance paradigm to implement these requirements - virtual interface, inheritance implementation, virtual polymorphism.\nHowever, virtual functions require forced dynamic dispatch and add virtual table pointers to class instances.\nSo let\u0026rsquo;s try to implement trait without using virtual inheritance.\nkeywords trait → Defines a trait. trait Speak { fn speak(\u0026amp;self) -\u0026gt; String; } impl → Implements a trait for a type. struct Dog; impl Speak for Dog { fn speak(\u0026amp;self) -\u0026gt; String { \u0026#34;Woof!\u0026#34;.to_string() } } where → Adds trait bounds in a structured way. fn make_speak\u0026lt;T\u0026gt;(animal: T) where T: Speak { println!(\u0026#34;{}\u0026#34;, animal.speak()); } dyn → Used for dynamic dispatch. fn speak_dyn(animal: \u0026amp;dyn Speak) { println!(\u0026#34;{}\u0026#34;, animal.speak()); } C++ Implementation Complete code The specific implementation may change, refer to the documentation in the repo\nInterface Definition When there\u0026rsquo;s no reflection for code generation, the interface needs to include delegate functionality\nrequires can only be used as constraints; it cannot be materialized into concrete functions, so we need to define concrete interface classes.\nNow we can define any interface class and write a set of function declarations.\nThen how do we call the implementation through the interface? For concrete instances, they should have concrete implementation functions that can be called normally. But considering the implementation of dyn, and that C++ cannot generate variable/function names through templates, I thought about having the interface class carry its own delegate implementation, which calls different implementations based on different situations.\ntemplate\u0026lt;typename T\u0026gt; struct Speak { auto speak() -\u0026gt; std::string { return M::template call\u0026lt;0\u0026gt;(this); } private: using M = TraitMeta\u0026lt;Speak, T\u0026gt;; friend M; template\u0026lt;typename F\u0026gt; static consteval auto collect() { return TraitApi { \u0026amp;F::speak }; } }; template call\u0026lt;X\u0026gt;: Looks up the function in the vtable and then calls it. For vtable, static dispatch references constexpr static variables, while dynamic dispatch references through pointers. collect: Helps to get the type and address of the interface without reflection. Since it\u0026rsquo;s a template, it can also be used to verify if the interface is correctly implemented. TraitApi: Internally, it\u0026rsquo;s a simple tuple that stores type information and addresses. Interface Implementation Common Customization Points in c++ include overloading, template specialization, Policy, and ADL.\nHere we choose template specialization, which is similar to how rust implements it.\nFor example, the Orphan Rule, which is the orphan principle for trait:\nImplement external Trait for your own types Implement your own Trait for external types From the perspective of c++, it\u0026rsquo;s easy to understand that these two rules ensure that the implementation of the Trait (i.e., template specialization) is visible to the compilation unit that references it (i.e., the .cpp/.cc that references the .h).\nThis avoids generating different implementations in different compilation units.\nstruct Dog; template\u0026lt;\u0026gt; struct Impl\u0026lt;Speak, Dog\u0026gt; { static auto speak(TraitPtr self) -\u0026gt; std::string; }; struct Dog : Speak\u0026lt;Dog\u0026gt; { std::string voice {\u0026#34;Woof!\u0026#34;}; }; auto Impl\u0026lt;Speak, Dog\u0026gt;::speak(TraitPtr self) -\u0026gt; std::string { return self.as_ref\u0026lt;Dog\u0026gt;().voice; } ... Impl accepts a Trait template and a concrete type. : Speak\u0026lt;Dog\u0026gt; non-virtual inheritance allows the Dog class to have concrete interface functions, i.e., Dog().speak(). Impl\u0026lt;Speak, Dog\u0026gt;::speak(Dog()) directly calls the implementation. It\u0026rsquo;s better to separate the fields definition of Dog.\nThis way, you can directly operate on Dog fields even when Dog is not yet defined.\nstruct Dog; struct DogFields { std::string voice {\u0026#34;Woof!\u0026#34;}; }; // Impl Speak\u0026lt;Dog\u0026gt; ... struct Dog : DogFields, Speak\u0026lt;Dog\u0026gt; {} Static Dispatch Use std::semiregular to determine if Impl is fully defined, or you can write a template to check the size.\ntemplate\u0026lt;typename A, template\u0026lt;typename\u0026gt; class... T\u0026gt; concept Implemented = (std::semiregular\u0026lt;Impl\u0026lt;T, A\u0026gt;\u0026gt; \u0026amp;\u0026amp; ...); // ... template\u0026lt;typename T\u0026gt; requires Implemented\u0026lt;T, Speak\u0026gt; void make_speak(T\u0026amp; animal) { std::print(\u0026#34;{}\u0026#34;, animal.speak()); } dyn Fat Pointer It stores a vtable pointer and a self pointer.\nThen use the dispatch functionality of the interface class to make the call.\ntemplate\u0026lt;template\u0026lt;typename\u0026gt; class Tr, ConstNess Cn\u0026gt; class Dyn : public Tr\u0026lt;DynImpl\u0026lt;Tr\u0026gt;\u0026gt; { using M = TraitMeta\u0026lt;Tr, DynImpl\u0026lt;Tr\u0026gt;\u0026gt;; friend M; using ptr_t = std::conditional_t\u0026lt;Cn == ConstNess::Const, const TraitPtr, TraitPtr\u0026gt;; const decltype(M::apis)* const apis; ptr_t self; ... } // ... Dog dog; auto dyn = make_dyn\u0026lt;Speak\u0026gt;(dog); std::print(\u0026#34;{}\u0026#34;, dyn.speak()); Tr: A Trait interface Tr\u0026lt;DynImpl\u0026lt;Tr\u0026gt;\u0026gt;: Uses the DynImpl tag to mark Tr, generating concrete call functions apis: vtable pointer Cn: Tr cannot have a const tag, so an additional parameter is needed to mark ConstNess Box dyn TODO\n","permalink":"https://blog.bluempty.com/en/post/cpp-rust-trait/","summary":"\u003cp\u003eI got in touch with \u003ccode\u003erust\u003c/code\u003e quite early and watched its ecosystem gradually improve.\u003cbr\u003e\nWhen I first used \u003ccode\u003etrait\u003c/code\u003e, I wondered how to implement such a great feature in \u003ccode\u003ec++\u003c/code\u003e.\u003cbr\u003e\nThough it wasn\u0026rsquo;t an urgent need, I put it aside. Recently, I tried to implement it in a simple way.\u003c/p\u003e\n\u003ch2 id=\"rust-trait\"\u003eRust Trait\u003c/h2\u003e\n\u003cp\u003eLet\u0026rsquo;s first look at an example of rust trait.\u003cbr\u003e\nSimply put, it\u0026rsquo;s about \u003cem\u003edefining interfaces, implementing interfaces, and interface polymorphism\u003c/em\u003e.\u003cbr\u003e\nActually, \u003ccode\u003ec++\u003c/code\u003e already has a complete inheritance paradigm to implement these requirements - \u003cem\u003evirtual interface, inheritance implementation, virtual polymorphism\u003c/em\u003e.\u003cbr\u003e\nHowever, virtual functions require forced dynamic dispatch and add virtual table pointers to class instances.\u003cbr\u003e\nSo let\u0026rsquo;s try to implement \u003ccode\u003etrait\u003c/code\u003e without using virtual inheritance.\u003c/p\u003e","title":"Simulating Rust Trait in C++"}]