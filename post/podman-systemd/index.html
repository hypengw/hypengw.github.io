<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>podman 使用体验 | Bluempty</title>
<meta name=keywords content="科技,Linux"><meta name=description content="日常经常需要使用容器，时常想要 docker 更轻量一些，比如不需要 daemon，不需要 root，普通用户就可以使用上。
然后被安利了 podman，使用了挺长时间了，以下是我的安利~"><meta name=author content="hypengw"><link rel=canonical href=https://blog.bluempty.com/post/podman-systemd/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.bluempty.com/images/profile.webp><link rel=icon type=image/png sizes=16x16 href=https://blog.bluempty.com/images/profile.webp><link rel=icon type=image/png sizes=32x32 href=https://blog.bluempty.com/images/profile.webp><link rel=apple-touch-icon href=https://blog.bluempty.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.bluempty.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.bluempty.com/post/podman-systemd/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/css/dimbox.min.css><meta property="og:url" content="https://blog.bluempty.com/post/podman-systemd/"><meta property="og:site_name" content="Bluempty"><meta property="og:title" content="podman 使用体验"><meta property="og:description" content="日常经常需要使用容器，时常想要 docker 更轻量一些，比如不需要 daemon，不需要 root，普通用户就可以使用上。
然后被安利了 podman，使用了挺长时间了，以下是我的安利~"><meta property="og:locale" content="zh-hans"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-01-19T10:43:33+08:00"><meta property="article:modified_time" content="2025-01-19T10:43:33+08:00"><meta property="article:tag" content="科技"><meta property="article:tag" content="Linux"><meta name=twitter:card content="summary"><meta name=twitter:title content="podman 使用体验"><meta name=twitter:description content="日常经常需要使用容器，时常想要 docker 更轻量一些，比如不需要 daemon，不需要 root，普通用户就可以使用上。
然后被安利了 podman，使用了挺长时间了，以下是我的安利~"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.bluempty.com/post/"},{"@type":"ListItem","position":2,"name":"podman 使用体验","item":"https://blog.bluempty.com/post/podman-systemd/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"podman 使用体验","name":"podman 使用体验","description":"日常经常需要使用容器，时常想要 docker 更轻量一些，比如不需要 daemon，不需要 root，普通用户就可以使用上。\n然后被安利了 podman，使用了挺长时间了，以下是我的安利~\n","keywords":["科技","Linux"],"articleBody":"日常经常需要使用容器，时常想要 docker 更轻量一些，比如不需要 daemon，不需要 root，普通用户就可以使用上。\n然后被安利了 podman，使用了挺长时间了，以下是我的安利~\ndaemonless 如题，podman 不需要跑一个 daemon 来管理容器。\n具体实现的话，大概是底层的 oci runtime 会在 XDG_RUNTIME_DIR 给每个容器一个独立的文件夹来存放一些状态信息，可以被 podman cli 读取和管理。\nsocket podman 仍然提供了通过 socket 来管理的功能，这个 socket 需要单独跑一个 daemon，不过非常轻，类似提供 podman cli 的功能同时带有验证。\nsystemctl --user status podman.socket\nsystemctl --user enable --now podman.socket\nrootless 与其把“权力”关进笼子里，不如一开始就分离需要“权力”的部分。\n普通用户使用 podman 默认就是 rootless。\n配置文件: ~/.config/containers\n容器存储: ~/.local/share/containers\nstorage driver overlay(default)\n需要安装 fuse-overlayfs btrfs\n推荐在 fstab 添加 user_subvol_rm_allowed 挂载选项，来源。 zfs… pasta User-Mode Networking slirp4netns 的替代，拥有更好的性能，是现在 podman 5.x 默认的网络实现(rootless)\npasta (same binary as passt, different command) offers equivalent functionality, for network namespaces: traffic is forwarded using a tap interface inside the namespace, without the need to create further interfaces on the host, hence not requiring any capabilities or privileges.\nStarting with Linux 3.8, unprivileged users can create network_namespaces(7) along with user_namespaces(7). However, unprivileged network namespaces had not been very useful, because creating veth(4) pairs across the host and network namespaces still requires the root privileges. (i.e. No internet connection)\nslirp4netns allows connecting a network namespace to the Internet in a completely unprivileged way, by connecting a TAP device in a network namespace to the usermode TCP/IP stack (“slirp”).\nhost.containers.internal 通过 /etc/hosts 设置，在使用 pasta 的情况下是指向 169.254.1.2 的特殊地址，指向本机，通常用于访问其他容器暴露的端口或者 host 的服务。\n但是无法访问监听 localhost 回环地址的服务，需要监听 0.0.0.0。\n性能测试 TODO\nUID 映射 默认 --userns=host\nKey Host User Container User auto $UID nil (Host User UID is not mapped into container.) host $UID 0 (Default User account mapped to root user in container.) keep-id $UID $UID (Map user account to same UID within container.) keep-id:uid=200,gid=210 $UID 200:210 (Map user account to specified UID, GID value within container.) nomap $UID nil (Host User UID is not mapped into container.) 具体来说，对于 rootless container：\n$ cat /etc/subuid :100000:65536 Container UID Host UID 0 1000 1 100000 2 100001 … … 1000 100999 pod podman 是支持 pod 的，不过没有 k8s 的许多企业化功能。\n共享网络子空间 共享硬件资源 共享资源限制 kube podman 支持用 Kubernetes YAML 来定义 pod。\n同时有自己的 metadata 和 volume 写法，具体可以阅读文档。\n博主个人是习惯把需要多个容器的服务用 pod 来写。\n支持的 Kubernetes kinds\nPod Deployment PersistentVolumeClaim ConfigMap Secret DaemonSet 这里给一个 yaml example:\napiVersion: v1 kind: Pod metadata: ... spec: containers: - name: container image: foobar ... systemd unit systemd units using Podman Quadlet\nQuadlet 现在是 systemd generator。\n这是我最看重的功能，通过 systemd 来管理 podman container。\n扫描的位置：\nroot: /etc/containers/systemd/\nuser: $XDG_CONFIG_HOME/containers/systemd/\n.container [Unit] Description=A minimal container [Container] # Use the centos image Image=quay.io/centos/centos:latest # Use volume and network defined below Volume=test.volume:/data # In the container we just run sleep Exec=sleep 60 [Service] # Restart service when sleep finishes Restart=always # Extend Timeout to allow time to pull the image TimeoutStartSec=900 [Install] # Start by default on boot WantedBy=multi-user.target default.target .kube 配合上文的 kube pod yaml\n[Unit] Description=A kubernetes yaml based service Before=local-fs.target [Kube] Yaml=%h/kube/test.yaml [Install] # Start by default on boot WantedBy=multi-user.target default.target auto-update 自动拉去新的 contianer image，然后重启 container，是一个 system service + timer。\n需要容器开启 AutoUpdate(.container)/io.containers.autoupdate(.kube metadata) 选项\nsystemctl --user enable podman-auto-update.timer\npodman auto-update\ndistrobox Use any Linux distribution inside your terminal. Enable both backward and forward compatibility with software and freedom to use whatever distribution you’re more comfortable with.\nRun any distribution as you need~\n","wordCount":"1018","inLanguage":"zh","datePublished":"2025-01-19T10:43:33+08:00","dateModified":"2025-01-19T10:43:33+08:00","author":{"@type":"Person","name":"hypengw"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.bluempty.com/post/podman-systemd/"},"publisher":{"@type":"Organization","name":"Bluempty","logo":{"@type":"ImageObject","url":"https://blog.bluempty.com/images/profile.webp"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.bluempty.com/ accesskey=h title="Bluempty (Alt + H)">Bluempty</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.bluempty.com/en/ title=En aria-label=En>En</a></li></ul></div></div><ul id=menu><li><a href=https://blog.bluempty.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.bluempty.com/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.bluempty.com/search/ title=搜索><span>搜索</span></a></li><li><a href=https://blog.bluempty.com/friends/ title=友链><span>友链</span></a></li><li><a href=https://blog.bluempty.com/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.bluempty.com/>主页</a>&nbsp;»&nbsp;<a href=https://blog.bluempty.com/post/>Posts</a></div><h1 class="post-title entry-hint-parent">podman 使用体验</h1><div class=post-meta><span title='2025-01-19 10:43:33 +0800 +0800'>一月 19, 2025</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;hypengw</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#daemonless aria-label=daemonless>daemonless</a><ul><li><a href=#socket aria-label=socket>socket</a></li></ul></li><li><a href=#rootless aria-label=rootless>rootless</a><ul><li><a href=#storage-driver aria-label="storage driver">storage driver</a></li><li><a href=#pastahttpspassttoppasstabout-user-mode-networking aria-label="pasta User-Mode Networking">pasta User-Mode Networking</a><ul><li><a href=#hostcontainersinternal aria-label=host.containers.internal>host.containers.internal</a></li><li><a href=#%e6%80%a7%e8%83%bd%e6%b5%8b%e8%af%95 aria-label=性能测试>性能测试</a></li></ul></li><li><a href=#uid-%e6%98%a0%e5%b0%84 aria-label="UID 映射">UID 映射</a></li></ul></li><li><a href=#podhttpsdocspodmanioenstablemarkdownpodman-pod-create1html aria-label=pod>pod</a><ul><li><a href=#kubehttpsdocspodmanioenstablemarkdownpodman-kube-play1html aria-label=kube>kube</a></li></ul></li><li><a href=#systemd-unithttpsdocspodmanioenlatestmarkdownpodman-systemdunit5html aria-label="systemd unit">systemd unit</a><ul><li><a href=#containerhttpsdocspodmanioenlatestmarkdownpodman-systemdunit5htmlcontainer-units-container aria-label=.container>.container</a></li><li><a href=#kubehttpsdocspodmanioenlatestmarkdownpodman-systemdunit5htmlpod-units-pod aria-label=.kube>.kube</a></li><li><a href=#auto-update aria-label=auto-update>auto-update</a></li></ul></li><li><a href=#distroboxhttpsgithubcom89luca89distroboxgit aria-label=distrobox>distrobox</a></li></ul></div></details></div><div class=post-content><p>日常经常需要使用容器，时常想要 docker 更轻量一些，比如不需要 daemon，不需要 root，普通用户就可以使用上。<br>然后被安利了 podman，使用了挺长时间了，以下是我的安利~</p><h2 id=daemonless>daemonless<a hidden class=anchor aria-hidden=true href=#daemonless>#</a></h2><p>如题，podman 不需要跑一个 daemon 来管理容器。<br>具体实现的话，大概是底层的 <a href=https://github.com/opencontainers/runtime-spec>oci runtime</a> 会在 <code>XDG_RUNTIME_DIR</code> 给每个容器一个独立的文件夹来存放一些状态信息，可以被 podman cli 读取和管理。</p><h3 id=socket>socket<a hidden class=anchor aria-hidden=true href=#socket>#</a></h3><p>podman 仍然提供了通过 socket 来管理的功能，这个 socket 需要单独跑一个 daemon，不过非常轻，类似提供 podman cli 的功能同时带有验证。</p><p><code>systemctl --user status podman.socket</code></p><p><code>systemctl --user enable --now podman.socket</code></p><h2 id=rootless>rootless<a hidden class=anchor aria-hidden=true href=#rootless>#</a></h2><p>与其把“权力”关进笼子里，不如一开始就分离需要“权力”的部分。<br>普通用户使用 podman 默认就是 <code>rootless</code>。</p><p>配置文件: <code>~/.config/containers</code><br>容器存储: <code>~/.local/share/containers</code></p><h3 id=storage-driver>storage driver<a hidden class=anchor aria-hidden=true href=#storage-driver>#</a></h3><ul><li>overlay(default)<br>需要安装 <code>fuse-overlayfs</code></li><li>btrfs<br>推荐在 fstab 添加 <code>user_subvol_rm_allowed</code> 挂载选项，<a href=https://github.com/containers/storage/pull/508>来源</a>。</li><li>zfs&mldr;</li></ul><h3 id=pastahttpspassttoppasstabout-user-mode-networking><a href=https://passt.top/passt/about/>pasta</a> User-Mode Networking<a hidden class=anchor aria-hidden=true href=#pastahttpspassttoppasstabout-user-mode-networking>#</a></h3><p><code>slirp4netns</code> 的替代，拥有更好的性能，是现在 podman 5.x 默认的网络实现(rootless)</p><blockquote><p><em>pasta</em> (same binary as <em>passt</em>, different command) offers equivalent functionality, for network namespaces: traffic is forwarded using a tap interface inside the namespace, without the need to create further interfaces on the host, hence not requiring any capabilities or privileges.</p></blockquote><blockquote><p>Starting with Linux 3.8, unprivileged users can create <a href=http://man7.org/linux/man-pages/man7/network_namespaces.7.html><code>network_namespaces(7)</code></a> along with <a href=http://man7.org/linux/man-pages/man7/user_namespaces.7.html><code>user_namespaces(7)</code></a>. However, unprivileged network namespaces had not been very useful, because creating <a href=http://man7.org/linux/man-pages/man4/veth.4.html><code>veth(4)</code></a> pairs across the host and network namespaces still requires the root privileges. (i.e. No internet connection)</p><p>slirp4netns allows connecting a network namespace to the Internet in a completely unprivileged way, by connecting a TAP device in a network namespace to the usermode TCP/IP stack (<a href=https://gitlab.freedesktop.org/slirp/libslirp>&ldquo;slirp&rdquo;</a>).</p></blockquote><h4 id=hostcontainersinternal>host.containers.internal<a hidden class=anchor aria-hidden=true href=#hostcontainersinternal>#</a></h4><p>通过 <code>/etc/hosts</code> 设置，在使用 pasta 的情况下是指向 <code>169.254.1.2</code> 的特殊地址，指向本机，通常用于访问其他容器暴露的端口或者 host 的服务。<br>但是无法访问监听 <code>localhost</code> 回环地址的服务，需要监听 <code>0.0.0.0</code>。</p><h4 id=性能测试>性能测试<a hidden class=anchor aria-hidden=true href=#性能测试>#</a></h4><p>TODO</p><h3 id=uid-映射>UID 映射<a hidden class=anchor aria-hidden=true href=#uid-映射>#</a></h3><p>默认 <code>--userns=host</code></p><table><thead><tr><th style=text-align:left>Key</th><th style=text-align:left>Host User</th><th style=text-align:left>Container User</th></tr></thead><tbody><tr><td style=text-align:left>auto</td><td style=text-align:left>$UID</td><td style=text-align:left>nil (Host User UID is not mapped into container.)</td></tr><tr><td style=text-align:left>host</td><td style=text-align:left>$UID</td><td style=text-align:left>0 (Default User account mapped to root user in container.)</td></tr><tr><td style=text-align:left>keep-id</td><td style=text-align:left>$UID</td><td style=text-align:left>$UID (Map user account to same UID within container.)</td></tr><tr><td style=text-align:left>keep-id:uid=200,gid=210</td><td style=text-align:left>$UID</td><td style=text-align:left>200:210 (Map user account to specified UID, GID value within container.)</td></tr><tr><td style=text-align:left>nomap</td><td style=text-align:left>$UID</td><td style=text-align:left>nil (Host User UID is not mapped into container.)</td></tr></tbody></table><p>具体来说，对于 <code>rootless container</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ cat /etc/subuid
</span></span><span class=line><span class=cl>&lt;login name&gt;:100000:65536
</span></span></code></pre></div><table><thead><tr><th style=text-align:left>Container UID</th><th style=text-align:left>Host UID</th></tr></thead><tbody><tr><td style=text-align:left>0</td><td style=text-align:left>1000</td></tr><tr><td style=text-align:left>1</td><td style=text-align:left>100000</td></tr><tr><td style=text-align:left>2</td><td style=text-align:left>100001</td></tr><tr><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td></tr><tr><td style=text-align:left>1000</td><td style=text-align:left>100999</td></tr></tbody></table><h2 id=podhttpsdocspodmanioenstablemarkdownpodman-pod-create1html><a href=https://docs.podman.io/en/stable/markdown/podman-pod-create.1.html>pod</a><a hidden class=anchor aria-hidden=true href=#podhttpsdocspodmanioenstablemarkdownpodman-pod-create1html>#</a></h2><p>podman 是支持 pod 的，不过没有 k8s 的许多企业化功能。</p><p><a href=/post/podman-systemd/assets/pod.svg data-dimbox data-dimbox-caption=pod><img alt=pod height=% loading=lazy src=/post/podman-systemd/assets/pod.svg width=%></a></p><ul><li>共享网络子空间</li><li>共享硬件资源</li><li>共享资源限制</li></ul><h3 id=kubehttpsdocspodmanioenstablemarkdownpodman-kube-play1html><a href=https://docs.podman.io/en/stable/markdown/podman-kube-play.1.html>kube</a><a hidden class=anchor aria-hidden=true href=#kubehttpsdocspodmanioenstablemarkdownpodman-kube-play1html>#</a></h3><p>podman 支持用 Kubernetes YAML 来定义 pod。<br>同时有自己的 metadata 和 volume 写法，具体可以阅读文档。<br>博主个人是习惯把需要多个容器的服务用 pod 来写。</p><p>支持的 Kubernetes kinds</p><ul><li>Pod</li><li>Deployment</li><li>PersistentVolumeClaim</li><li>ConfigMap</li><li>Secret</li><li>DaemonSet</li></ul><p>这里给一个 yaml example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nn>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>container</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>foobar</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nn>...</span><span class=w>
</span></span></span></code></pre></div><h2 id=systemd-unithttpsdocspodmanioenlatestmarkdownpodman-systemdunit5html><a href=https://docs.podman.io/en/latest/markdown/podman-systemd.unit.5.html>systemd unit</a><a hidden class=anchor aria-hidden=true href=#systemd-unithttpsdocspodmanioenlatestmarkdownpodman-systemdunit5html>#</a></h2><p>systemd units using Podman Quadlet<br>Quadlet 现在是 <a href=https://www.freedesktop.org/software/systemd/man/latest/systemd.generator.html>systemd generator</a>。<br>这是我最看重的功能，通过 systemd 来管理 podman container。</p><p>扫描的位置：<br><code>root</code>: <code>/etc/containers/systemd/</code><br><code>user</code>: <code>$XDG_CONFIG_HOME/containers/systemd/</code></p><h3 id=containerhttpsdocspodmanioenlatestmarkdownpodman-systemdunit5htmlcontainer-units-container><a href=https://docs.podman.io/en/latest/markdown/podman-systemd.unit.5.html#container-units-container>.container</a><a hidden class=anchor aria-hidden=true href=#containerhttpsdocspodmanioenlatestmarkdownpodman-systemdunit5htmlcontainer-units-container>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-systemd data-lang=systemd><span class=line><span class=cl><span class=k>[Unit]</span>
</span></span><span class=line><span class=cl><span class=na>Description</span><span class=o>=</span><span class=s>A minimal container</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>[Container]</span>
</span></span><span class=line><span class=cl><span class=c># Use the centos image</span>
</span></span><span class=line><span class=cl><span class=na>Image</span><span class=o>=</span><span class=s>quay.io/centos/centos:latest</span>
</span></span><span class=line><span class=cl><span class=c># Use volume and network defined below</span>
</span></span><span class=line><span class=cl><span class=na>Volume</span><span class=o>=</span><span class=s>test.volume:/data</span>
</span></span><span class=line><span class=cl><span class=c># In the container we just run sleep</span>
</span></span><span class=line><span class=cl><span class=na>Exec</span><span class=o>=</span><span class=s>sleep 60</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>[Service]</span>
</span></span><span class=line><span class=cl><span class=c># Restart service when sleep finishes</span>
</span></span><span class=line><span class=cl><span class=na>Restart</span><span class=o>=</span><span class=s>always</span>
</span></span><span class=line><span class=cl><span class=c># Extend Timeout to allow time to pull the image</span>
</span></span><span class=line><span class=cl><span class=na>TimeoutStartSec</span><span class=o>=</span><span class=s>900</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>[Install]</span>
</span></span><span class=line><span class=cl><span class=c># Start by default on boot</span>
</span></span><span class=line><span class=cl><span class=na>WantedBy</span><span class=o>=</span><span class=s>multi-user.target default.target</span>
</span></span></code></pre></div><h3 id=kubehttpsdocspodmanioenlatestmarkdownpodman-systemdunit5htmlpod-units-pod><a href=https://docs.podman.io/en/latest/markdown/podman-systemd.unit.5.html#pod-units-pod>.kube</a><a hidden class=anchor aria-hidden=true href=#kubehttpsdocspodmanioenlatestmarkdownpodman-systemdunit5htmlpod-units-pod>#</a></h3><p>配合上文的 kube pod yaml</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-systemd data-lang=systemd><span class=line><span class=cl><span class=k>[Unit]</span>
</span></span><span class=line><span class=cl><span class=na>Description</span><span class=o>=</span><span class=s>A kubernetes yaml based service</span>
</span></span><span class=line><span class=cl><span class=na>Before</span><span class=o>=</span><span class=s>local-fs.target</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>[Kube]</span>
</span></span><span class=line><span class=cl><span class=na>Yaml</span><span class=o>=</span><span class=s>%h/kube/test.yaml</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>[Install]</span>
</span></span><span class=line><span class=cl><span class=c># Start by default on boot</span>
</span></span><span class=line><span class=cl><span class=na>WantedBy</span><span class=o>=</span><span class=s>multi-user.target default.target</span>
</span></span></code></pre></div><h3 id=auto-update>auto-update<a hidden class=anchor aria-hidden=true href=#auto-update>#</a></h3><p>自动拉去新的 contianer image，然后重启 container，是一个 system service + timer。<br>需要容器开启 <code>AutoUpdate(.container)/io.containers.autoupdate(.kube metadata)</code> 选项</p><p><code>systemctl --user enable podman-auto-update.timer</code><br><code>podman auto-update</code></p><h2 id=distroboxhttpsgithubcom89luca89distroboxgit><a href=https://github.com/89luca89/distrobox.git>distrobox</a><a hidden class=anchor aria-hidden=true href=#distroboxhttpsgithubcom89luca89distroboxgit>#</a></h2><blockquote><p>Use any Linux distribution inside your terminal. Enable both backward and forward compatibility with software and freedom to use whatever distribution you’re more comfortable with.</p></blockquote><p>Run any distribution as you need~</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.bluempty.com/tags/%E7%A7%91%E6%8A%80/>科技</a></li><li><a href=https://blog.bluempty.com/tags/linux/>Linux</a></li></ul><nav class=paginav><a class=prev href=https://blog.bluempty.com/post/finding-serenity/><span class=title>« 上一页</span><br><span>寻找名为安心的小岛</span>
</a><a class=next href=https://blog.bluempty.com/post/xiaomi-eu-kernel-su-mount/><span class=title>下一页 »</span><br><span>HyperOS.eu KernelSU 卸载模块不工作</span></a></nav></footer></article></main><footer class=footer><span>© 2025 <a href=https://blog.bluempty.com>Bluempty</a> · <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=/js/dimbox.min.js></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>