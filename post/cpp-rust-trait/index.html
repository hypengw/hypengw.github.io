<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ 模拟 Rust Trait | Bluempty</title>
<meta name=keywords content="编程"><meta name=description content="接触 rust 倒是挺早了，看着它的生态慢慢好起来。
第一次用上 trait 就在想，这么好的东西，该怎么在 c++ 里用上呢。
不过不算刚需，就一直搁置着，最近尝试简单实现了一下。"><meta name=author content="hypengw"><link rel=canonical href=https://blog.bluempty.com/post/cpp-rust-trait/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.bluempty.com/images/profile.webp><link rel=icon type=image/png sizes=16x16 href=https://blog.bluempty.com/images/profile.webp><link rel=icon type=image/png sizes=32x32 href=https://blog.bluempty.com/images/profile.webp><link rel=apple-touch-icon href=https://blog.bluempty.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.bluempty.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.bluempty.com/post/cpp-rust-trait/><link rel=alternate hreflang=en href=https://blog.bluempty.com/en/post/cpp-rust-trait/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/css/dimbox.min.css><meta property="og:url" content="https://blog.bluempty.com/post/cpp-rust-trait/"><meta property="og:site_name" content="Bluempty"><meta property="og:title" content="C++ 模拟 Rust Trait"><meta property="og:description" content="接触 rust 倒是挺早了，看着它的生态慢慢好起来。
第一次用上 trait 就在想，这么好的东西，该怎么在 c++ 里用上呢。
不过不算刚需，就一直搁置着，最近尝试简单实现了一下。"><meta property="og:locale" content="zh-hans"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-03-12T22:11:24+08:00"><meta property="article:modified_time" content="2025-03-12T22:11:24+08:00"><meta property="article:tag" content="编程"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++ 模拟 Rust Trait"><meta name=twitter:description content="接触 rust 倒是挺早了，看着它的生态慢慢好起来。
第一次用上 trait 就在想，这么好的东西，该怎么在 c++ 里用上呢。
不过不算刚需，就一直搁置着，最近尝试简单实现了一下。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.bluempty.com/post/"},{"@type":"ListItem","position":2,"name":"C++ 模拟 Rust Trait","item":"https://blog.bluempty.com/post/cpp-rust-trait/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ 模拟 Rust Trait","name":"C\u002b\u002b 模拟 Rust Trait","description":"接触 rust 倒是挺早了，看着它的生态慢慢好起来。\n第一次用上 trait 就在想，这么好的东西，该怎么在 c++ 里用上呢。\n不过不算刚需，就一直搁置着，最近尝试简单实现了一下。\n","keywords":["编程"],"articleBody":"接触 rust 倒是挺早了，看着它的生态慢慢好起来。\n第一次用上 trait 就在想，这么好的东西，该怎么在 c++ 里用上呢。\n不过不算刚需，就一直搁置着，最近尝试简单实现了一下。\nRust Trait 先来看看 rust trait 的例子。\n简单来说，就是 “定义接口，实现接口，接口多态”。\n其实 c++ 这边已经有一套完整的继承范式来实现上述需求了，“虚接口，继承实现，虚多态”。\n不过虚函数会要求强制动态分发，然后给类实例添加虚表指针。\n所以要尝试不用虚继承来实现 trait。\nkeywords trait → Defines a trait. trait Speak { fn speak(\u0026self) -\u003e String; } impl → Implements a trait for a type. struct Dog; impl Speak for Dog { fn speak(\u0026self) -\u003e String { \"Woof!\".to_string() } } where → Adds trait bounds in a structured way. fn make_speak\u003cT\u003e(animal: T) where T: Speak { println!(\"{}\", animal.speak()); } dyn → Used for dynamic dispatch. fn speak_dyn(animal: \u0026dyn Speak) { println!(\"{}\", animal.speak()); } C++ 实现 完整的代码\n具体的实现可能会改变，参考 repo 里的文档\n接口定义 在没有反射的代码生成时，接口需要同时带有 delegate 功能\nrequires 只能用作约束，它无法落地成具体的函数，所以需要定义具体的接口类。\n现在我们可以定义任意接口类，然后写一套函数的声明。\n然后该怎么通过接口去调用实现呢，如果是具体的实例，它应该会拥有具体的实现函数，可以正常调用。但是考虑 dyn 的实现，以及C++没法通过模板去生成变量/函数的名字，我想的是让接口类自己带有 delegate 的实现，根据情况的不同，去调用不同的实现。\ntemplate\u003ctypename T\u003e struct Speak { auto speak() -\u003e std::string { return M::template call\u003c0\u003e(this); } private: using M = TraitMeta\u003cSpeak, T\u003e; friend M; template\u003ctypename F\u003e static consteval auto collect() { return TraitApi { \u0026F::speak }; } }; template call: 查找 vtable 里的函数，然后调用。\n对于 vtable，静态分发是引用 constexpr static 变量，动态分发是通过指针引用。 collect: 在没有反射的情况下，帮助获取接口的类型和地址。由于是模板，所以也可以用于验证接口是否被正确实现。 TraitApi: 内部是一个简单 tuple，存储类型信息和地址。 接口实现 c++ 里常见的 Customization Points 有 重载，模板特化，Policy 以及 ADL。\n这里我们选择模板特化，rust 其实也是类似的实现。\n比如，Orphan Rule，即对 trait 的孤儿原则：\n为自己的类型实现外部 Trait 为外部类型实现自己的 Trait 在 c++ 的视角下，非常好理解，这两条规则都是为了让 Trait 的实现（即模板特化）对引用它的编译单元（即引用 .h 的 .cpp/.cc）一定可见。\n这样就能避免在不同的编译单元产生不同的实现。\nstruct Dog; template\u003c\u003e struct Impl\u003cSpeak, Dog\u003e { static auto speak(TraitPtr self) -\u003e std::string; }; struct Dog : Speak\u003cDog\u003e { std::string voice {\"Woof!\"}; }; auto Impl\u003cSpeak, Dog\u003e::speak(TraitPtr self) -\u003e std::string { return self.as_ref\u003cDog\u003e().voice; } ... Impl 接受一个 Trait 模板和具体类型。 : Speak 非虚继承，来让 Dog 类拥有具体的接口函数，即 Dog().speak()。 Impl::speak(Dog()) 直接调用实现。 这里把 Dog 的 fields 分开定义会好一些。\n这样可以在 Dog 还未定义的时候，直接操作 Dog fileds。\nstruct Dog; struct DogFields { std::string voice {\"Woof!\"}; }; // Impl Speak ... struct Dog : DogFields, Speak\u003cDog\u003e {} 静态分发 用 std::semiregular 来判断 Impl 是否有完整定义，当然也可以自己写模板判断 size。\ntemplate\u003ctypename A, template\u003ctypename\u003e class... T\u003e concept Implemented = (std::semiregular\u003cImpl\u003cT, A\u003e\u003e \u0026\u0026 ...); // ... template\u003ctypename T\u003e requires Implemented\u003cT, Speak\u003e void make_speak(T\u0026 animal) { std::print(\"{}\", animal.speak()); } dyn 胖指针 即存储一个 vtable 指针和 self 指针。\n然后利用接口类的分发功能来实现调用。\ntemplate\u003ctemplate\u003ctypename\u003e class Tr, ConstNess Cn\u003e class Dyn : public Tr\u003cDynImpl\u003cTr\u003e\u003e { using M = TraitMeta\u003cTr, DynImpl\u003cTr\u003e\u003e; friend M; using ptr_t = std::conditional_t\u003cCn == ConstNess::Const, const TraitPtr, TraitPtr\u003e; const decltype(M::apis)* const apis; ptr_t self; ... } // ... Dog dog; auto dyn = make_dyn\u003cSpeak\u003e(dog); std::print(\"{}\", dyn.speak()); Tr: 一个 Trait 接口 Tr","wordCount":"1237","inLanguage":"zh","datePublished":"2025-03-12T22:11:24+08:00","dateModified":"2025-03-12T22:11:24+08:00","author":{"@type":"Person","name":"hypengw"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.bluempty.com/post/cpp-rust-trait/"},"publisher":{"@type":"Organization","name":"Bluempty","logo":{"@type":"ImageObject","url":"https://blog.bluempty.com/images/profile.webp"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.bluempty.com/ accesskey=h title="Bluempty (Alt + H)">Bluempty</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.bluempty.com/en/ title=En aria-label=En>En</a></li></ul></div></div><ul id=menu><li><a href=https://blog.bluempty.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.bluempty.com/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.bluempty.com/search/ title=搜索><span>搜索</span></a></li><li><a href=https://blog.bluempty.com/friends/ title=友链><span>友链</span></a></li><li><a href=https://blog.bluempty.com/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.bluempty.com/>主页</a>&nbsp;»&nbsp;<a href=https://blog.bluempty.com/post/>Posts</a></div><h1 class="post-title entry-hint-parent">C++ 模拟 Rust Trait</h1><div class=post-meta><span title='2025-03-12 22:11:24 +0800 +0800'>三月 12, 2025</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;hypengw&nbsp;|&nbsp;语言:<ul class=i18n_list><li><a href=https://blog.bluempty.com/en/post/cpp-rust-trait/>En</a></li></ul></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#rust-trait aria-label="Rust Trait">Rust Trait</a><ul><li><a href=#keywords aria-label=keywords>keywords</a></li></ul></li><li><a href=#c-%e5%ae%9e%e7%8e%b0 aria-label="C++ 实现">C++ 实现</a><ul><li><a href=#%e6%8e%a5%e5%8f%a3%e5%ae%9a%e4%b9%89 aria-label=接口定义>接口定义</a></li><li><a href=#%e6%8e%a5%e5%8f%a3%e5%ae%9e%e7%8e%b0 aria-label=接口实现>接口实现</a></li><li><a href=#%e9%9d%99%e6%80%81%e5%88%86%e5%8f%91 aria-label=静态分发>静态分发</a></li><li><a href=#dyn-%e8%83%96%e6%8c%87%e9%92%88 aria-label="dyn 胖指针">dyn 胖指针</a></li><li><a href=#box-dyn aria-label="Box dyn">Box dyn</a></li></ul></li></ul></div></details></div><div class=post-content><p>接触 <code>rust</code> 倒是挺早了，看着它的生态慢慢好起来。<br>第一次用上 <code>trait</code> 就在想，这么好的东西，该怎么在 <code>c++</code> 里用上呢。<br>不过不算刚需，就一直搁置着，最近尝试简单实现了一下。</p><h2 id=rust-trait>Rust Trait<a hidden class=anchor aria-hidden=true href=#rust-trait>#</a></h2><p>先来看看 rust trait 的例子。<br>简单来说，就是 &ldquo;定义接口，实现接口，接口多态&rdquo;。<br>其实 <code>c++</code> 这边已经有一套完整的继承范式来实现上述需求了，&ldquo;虚接口，继承实现，虚多态&rdquo;。<br>不过虚函数会要求强制动态分发，然后给类实例添加虚表指针。<br>所以要尝试不用虚继承来实现 <code>trait</code>。</p><h3 id=keywords>keywords<a hidden class=anchor aria-hidden=true href=#keywords>#</a></h3><ul><li>trait → Defines a trait.<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>Speak</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>speak</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>String</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li>impl → Implements a trait for a type.<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Dog</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Speak</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Dog</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>speak</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>String</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=s>&#34;Woof!&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li>where → Adds trait bounds in a structured way.<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>make_speak</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>animal</span>: <span class=nc>T</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>T</span>: <span class=nc>Speak</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>animal</span><span class=p>.</span><span class=n>speak</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li>dyn → Used for dynamic dispatch.<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>speak_dyn</span><span class=p>(</span><span class=n>animal</span>: <span class=kp>&amp;</span><span class=nc>dyn</span><span class=w> </span><span class=n>Speak</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>animal</span><span class=p>.</span><span class=n>speak</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li></ul><h2 id=c-实现>C++ 实现<a hidden class=anchor aria-hidden=true href=#c-实现>#</a></h2><p><a href=https://github.com/hypengw/rstd/blob/master/src/core/trait.cppm>完整的代码</a><br>具体的实现可能会改变，参考 repo 里的文档</p><h3 id=接口定义>接口定义<a hidden class=anchor aria-hidden=true href=#接口定义>#</a></h3><blockquote><p>在没有反射的代码生成时，接口需要同时带有 delegate 功能</p></blockquote><p><code>requires</code> 只能用作约束，它无法落地成具体的函数，所以需要定义具体的接口类。<br>现在我们可以定义任意接口类，然后写一套函数的声明。<br>然后该怎么通过接口去调用实现呢，如果是具体的实例，它应该会拥有具体的实现函数，可以正常调用。但是考虑 <code>dyn</code> 的实现，以及<strong>C++没法通过模板去生成变量/函数的名字</strong>，我想的是让接口类自己带有 <code>delegate</code> 的实现，根据情况的不同，去调用不同的实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Speak</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=nf>speak</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=p>{</span> <span class=k>return</span> <span class=n>M</span><span class=o>::</span><span class=k>template</span> <span class=n>call</span><span class=o>&lt;</span><span class=mi>0</span><span class=o>&gt;</span><span class=p>(</span><span class=k>this</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>M</span> <span class=o>=</span> <span class=n>TraitMeta</span><span class=o>&lt;</span><span class=n>Speak</span><span class=p>,</span> <span class=n>T</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=n>M</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>F</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>consteval</span> <span class=k>auto</span> <span class=n>collect</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>TraitApi</span> <span class=p>{</span> <span class=o>&amp;</span><span class=n>F</span><span class=o>::</span><span class=n>speak</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ul><li><code>template call&lt;X></code>: 查找 <code>vtable</code> 里的函数，然后调用。<br>对于 <code>vtable</code>，静态分发是引用 <code>constexpr static</code> 变量，动态分发是通过指针引用。</li><li><code>collect</code>: 在没有反射的情况下，帮助获取接口的类型和地址。由于是模板，所以也可以用于验证接口是否被正确实现。</li><li><code>TraitApi</code>: 内部是一个简单 <code>tuple</code>，存储类型信息和地址。</li></ul><h3 id=接口实现>接口实现<a hidden class=anchor aria-hidden=true href=#接口实现>#</a></h3><p><code>c++</code> 里常见的 <code>Customization Points</code> 有 重载，模板特化，Policy 以及 ADL。<br>这里我们选择模板特化，<code>rust</code> 其实也是类似的实现。<br>比如，<code>Orphan Rule</code>，即对 <code>trait</code> 的孤儿原则：</p><ul><li>为自己的类型实现外部 Trait</li><li>为外部类型实现自己的 Trait</li></ul><p>在 <code>c++</code> 的视角下，非常好理解，这两条规则都是为了让 Trait 的实现（即模板特化）对引用它的编译单元（即引用 <code>.h</code> 的 <code>.cpp/.cc</code>）一定可见。<br>这样就能避免在不同的编译单元产生不同的实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Dog</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Impl</span><span class=o>&lt;</span><span class=n>Speak</span><span class=p>,</span> <span class=n>Dog</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>auto</span> <span class=nf>speak</span><span class=p>(</span><span class=n>TraitPtr</span> <span class=n>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Dog</span> <span class=o>:</span> <span class=n>Speak</span><span class=o>&lt;</span><span class=n>Dog</span><span class=o>&gt;</span>  <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>voice</span> <span class=p>{</span><span class=s>&#34;Woof!&#34;</span><span class=p>};</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>Impl</span><span class=o>&lt;</span><span class=n>Speak</span><span class=p>,</span> <span class=n>Dog</span><span class=o>&gt;::</span><span class=n>speak</span><span class=p>(</span><span class=n>TraitPtr</span> <span class=n>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>self</span><span class=p>.</span><span class=n>as_ref</span><span class=o>&lt;</span><span class=n>Dog</span><span class=o>&gt;</span><span class=p>().</span><span class=n>voice</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span></code></pre></div><ul><li><code>Impl</code> 接受一个 Trait 模板和具体类型。</li><li><code>: Speak&lt;Dog></code> 非虚继承，来让 <code>Dog</code> 类拥有具体的接口函数，即 <code>Dog().speak()</code>。</li><li><code>Impl&lt;Speak, Dog>::speak(Dog())</code> 直接调用实现。</li></ul><p>这里把 <code>Dog</code> 的 <code>fields</code> 分开定义会好一些。<br>这样可以在 <code>Dog</code> 还未定义的时候，直接操作 <code>Dog fileds</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Dog</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>DogFields</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>voice</span> <span class=p>{</span><span class=s>&#34;Woof!&#34;</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// Impl Speak&lt;Dog&gt; ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>Dog</span> <span class=o>:</span> <span class=n>DogFields</span><span class=p>,</span> <span class=n>Speak</span><span class=o>&lt;</span><span class=n>Dog</span><span class=o>&gt;</span> <span class=p>{}</span>
</span></span></code></pre></div><h3 id=静态分发>静态分发<a hidden class=anchor aria-hidden=true href=#静态分发>#</a></h3><p>用 <code>std::semiregular</code> 来判断 <code>Impl</code> 是否有完整定义，当然也可以自己写模板判断 <code>size</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>A</span><span class=p>,</span> <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span><span class=o>&gt;</span> <span class=k>class</span><span class=err>... </span><span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>concept</span> <span class=n>Implemented</span> <span class=o>=</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>semiregular</span><span class=o>&lt;</span><span class=n>Impl</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>A</span><span class=o>&gt;&gt;</span> <span class=o>&amp;&amp;</span> <span class=p>...);</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>requires</span> <span class=n>Implemented</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>Speak</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>make_speak</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span> <span class=n>animal</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>print</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span> <span class=n>animal</span><span class=p>.</span><span class=n>speak</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=dyn-胖指针>dyn 胖指针<a hidden class=anchor aria-hidden=true href=#dyn-胖指针>#</a></h3><p>即存储一个 <code>vtable</code> 指针和 <code>self</code> 指针。<br>然后利用接口类的分发功能来实现调用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Tr</span><span class=p>,</span> <span class=n>ConstNess</span> <span class=n>Cn</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Dyn</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Tr</span><span class=o>&lt;</span><span class=n>DynImpl</span><span class=o>&lt;</span><span class=n>Tr</span><span class=o>&gt;&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>M</span> <span class=o>=</span> <span class=n>TraitMeta</span><span class=o>&lt;</span><span class=n>Tr</span><span class=p>,</span> <span class=n>DynImpl</span><span class=o>&lt;</span><span class=n>Tr</span><span class=o>&gt;&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=n>M</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>ptr_t</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>conditional_t</span><span class=o>&lt;</span><span class=n>Cn</span> <span class=o>==</span> <span class=n>ConstNess</span><span class=o>::</span><span class=n>Const</span><span class=p>,</span> <span class=k>const</span> <span class=n>TraitPtr</span><span class=p>,</span> <span class=n>TraitPtr</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=nf>decltype</span><span class=p>(</span><span class=n>M</span><span class=o>::</span><span class=n>apis</span><span class=p>)</span><span class=o>*</span> <span class=k>const</span> <span class=n>apis</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ptr_t</span>                          <span class=n>self</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>Dog</span> <span class=n>dog</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>dyn</span> <span class=o>=</span> <span class=n>make_dyn</span><span class=o>&lt;</span><span class=n>Speak</span><span class=o>&gt;</span><span class=p>(</span><span class=n>dog</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>print</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span> <span class=n>dyn</span><span class=p>.</span><span class=n>speak</span><span class=p>());</span>
</span></span></code></pre></div><ul><li><code>Tr</code>: 一个 <code>Trait</code> 接口</li><li><code>Tr&lt;DynImpl&lt;Tr>></code>： 即用 <code>DynImpl</code> 标签标记给 <code>Tr</code>，生成具体的调用函数</li><li><code>apis</code>: <code>vtable</code> 指针</li><li><code>Cn</code>: <code>Tr</code> 无法拥有 <code>const</code> 标记，所以需要额外的参数来标记 <code>ConstNess</code></li></ul><h3 id=box-dyn>Box dyn<a hidden class=anchor aria-hidden=true href=#box-dyn>#</a></h3><p>TODO</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.bluempty.com/tags/%E7%BC%96%E7%A8%8B/>编程</a></li></ul><nav class=paginav><a class=next href=https://blog.bluempty.com/post/kindle-module/><span class=title>下一页 »</span><br><span>Kindle 也有自己的 Magisk 模块</span></a></nav></footer></article></main><footer class=footer><span>© 2025 <a href=https://blog.bluempty.com>Bluempty</a> · <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=/js/dimbox.min.js></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>